#!/usr/bin/env bash
# This script allows changing the color of folders in Papirus icon theme
#
# @author: Sergei Eremenko (https://github.com/SmartFinn)
# @license: MIT license (MIT)
# @link: https://github.com/PapirusDevelopmentTeam/papirus-folders

if test -z "$BASH_VERSION"; then
	printf "Error: this script only works in bash.\n" >&2
	exit 1
fi

if (( BASH_VERSINFO[0] * 10 + BASH_VERSINFO[1] < 42 )); then
	printf "Error: this script requires bash version >= 4.2\n" >&2
	exit 1
fi

# set -x  # Uncomment to debug this shell script
set -o errexit \
	-o noclobber \
	-o pipefail

readonly THIS_SCRIPT="$(readlink -f "$0")"
readonly PROGNAME="$(basename "$0")"
readonly VERSION="0.0.1"
readonly -a ARGS=("$@")

readonly DEFAULT_COLOR="blue"
readonly THEME_NAME="Papirus"

_msg() {
	(( "$#" )) || return 0
	[ "$TERM" != "dumb" ] || return 0
	printf "%s: %s\n" "$PROGNAME" "$*" >&2
}

_verbose() {
	(( VERBOSE )) || return 0
	_msg "$@"
}

_exit() {
	_msg "$@" "Exiting..."
	exit 0
}

_fail() {
	_msg "Error:" "$@"
	exit 1
}

_fatal() { _fail "${FUNCNAME[1]} at line ${BASH_LINENO[0]}"; }
_opt_err() { _fail "only one operation may be used at a time."; }

usage() {
	cat >&2 <<- EOF
	usage:
	  $PROGNAME {-C --color} <color> [options]
	  $PROGNAME {-D --default} [options]
	  $PROGNAME {-R --restore} [options]

	OPERATIONS:
	  -C --color <color>   change color of folders
	  -D --default         back to the default color
	  -R --restore         restore color from a config file

	OPTIONS:
	  -l --list            show available colors
	  -u --update-caches   update icon caches
	  -V --version         print $PROGNAME version and exit
	  -v --verbose         be verbose
	  -h --help            show this help
	EOF

	exit "${1:-0}"
}

get_colors() {
	local -r -a valid_colors=("black" "blue" "brown" "cyan" "green"
		"grey" "magenta" "orange" "pink" "purple" "red" "violet"
		"yellow")
	local color=''
	local -a colors=()

	for color in "${valid_colors[@]}"; do
		if [ -e "$THEME_DIR/48x48/places/folder-$color.svg" ]; then
			colors=( "${colors[@]}" "$color" )
		fi
	done

	# return array of colors
	declare -p colors
}

get_current_color() {
	local icon_file icon_name current_color=''

	icon_file=$(readlink -f "$THEME_DIR/48x48/places/folder.svg")
	icon_name=$(basename -s .svg "$icon_file")
	current_color="${icon_name##*-}"

	declare -p current_color
}

change_color() {
	[ -n "$1" ] || return 1

	local -r color="$1"
	local -r sizes_regex="(22x22|24x24|32x32|48x48|64x64)"
	local -r icons_regex="(folder|user)-$color"
	local file target symlink

	_verbose "Changing color of folders to '$color'..."
	find "$THEME_DIR" -regextype posix-extended \
		-regex ".*/${sizes_regex}/places/${icons_regex}.*" \
		-print0 | while read -d $'\0' file; do

		target="$(basename "$file")"
		symlink="${file/-$color/}"

		ln -sf "$target" "$symlink" || _fail \
			"cannot create '$symlink' symlink"
	done
}

get_user() {
	local user user_dir

	if [ -n "$PKEXEC_UID" ]; then
		user="$(id -nu "$PKEXEC_UID")"
	elif [ -n "$SUDO_USER" ]; then
		user="$SUDO_USER"
	else
		user="$USER"
	fi

	user_dir="$(getent passwd "$user" | awk -F: '{print $6}')"

	declare -p user user_dir
}

config() {
	# usage: config [{-n --new}] {-s --set} key=value... | {-g --get} key...
	local config_dir
	local config_file

	if _is_system_dir; then
		config_file="/var/lib/$PROGNAME/keep"
	else
		config_file="${XDG_CONFIG_HOME:-$HOME/.config}/$PROGNAME/keep"
	fi

	config_dir="$(dirname "$config_file")"

	while (( "$#" )); do
		case "$1" in
			-g|--get) shift;
				[ -f "$config_file" ] || return 1

				for key; do
					[ -n "$key" ] || continue
					sed -n "
						/^[[:space:]]*${key}=/ {
							# remove everything before the equal sign
							s/[^=]*=//p
							# get only the first match
							:loop
							n
							b loop
						}" "$config_file"
				done

				break
				;;
			-n|--new) shift;
				rm -f "$config_file"
				;;
			-s|--set) shift;
				[ -d "$config_dir"  ] || mkdir -p "$config_dir"
				[ -f "$config_file" ] || touch "$config_file"

				_verbose "Saving params to '$config_file'..."

				cat >> "$config_file" <<- EOF
					$(for i; do echo "$i"; done)
				EOF

				break
				;;
			*)
				return 1
				;;
		esac
	done

	return 0
}

update_icon_caches() {
	declare -a icon_themes=(
		$(find "$THEME_DIR/.." -iname "*$THEME_NAME*" -type d )
	)

	eval "$(get_user)"

	declare -a icon_caches=(
		# KDE 5 icon caches
		"$user_dir/.cache/icon-cache.kcache"
		"/var/tmp/kdecache-$user/icon-cache.kcache"
		# KDE 4 icon caches
		"$user_dir/.kde4/cache-$(hostname)/icon-cache.kcache"
	)

	_verbose "Deleting icon caches..."
	for i in "${icon_caches[@]}"; do
		[ -e "$i" ] || continue
		rm -f "$i"
	done

	_verbose "Rebuilding icon caches..."
	for i in "${icon_themes[@]}"; do
		gtk-update-icon-cache -qf "$i" || true
	done
}

_is_valid_color() {
	local -r color="$1"

	eval "$(get_colors)"

	for i in "${colors[@]}"; do
		[ "$i" == "$color" ] || continue
		return 0
	done

	return 1
}

_is_system_dir() {
	if [ "${THEME_DIR:0:4}" == "/usr" ]; then
		return 0
	fi

	return 1
}

_is_root_user() {
	if [ "$(id -u)" -eq 0 ]; then
		return 0
	fi

	return 1
}

verify_privileges() {
	_is_root_user  && return 0
	_is_system_dir || return 0

	_verbose "This operation requires root privileges."

	if command -v sudo > /dev/null; then
		exec sudo "$THIS_SCRIPT" "${ARGS[@]}"
	else
		_fail "You need to be root to run this command."
	fi
}

cmdline() {
	local arg='' opt='' OPT=''
	local -a args=()

	# Translate --gnu-long-options to -g (short options)
	for arg; do
		opt="-${arg:2:1}"  # short option in lowercase
		OPT="${opt^^}"     # short option in uppercase

		case "$arg" in
			--help          | \
			--list          | \
			--update-caches | \
			--verbose) args=("${args[@]}" "$opt") ;;
			--color         | \
			--default       | \
			--restore       | \
			--version) args=("${args[@]}" "$OPT") ;;
			--[a-z]*)
				_msg "illegal option -- '$arg'"
				usage 1
				;;
			*)         args=("${args[@]}" "$arg") ;;
		esac
	done

	# Reset the positional parameters to the short options
	eval set -- "${args[@]}"

	local operation=""
	local -a options=()

	while getopts "c:C:dDhlrRuvV" OPTION; do
		case "$OPTION" in
			c|C)
				[ -z "$operation" ] || _opt_err
				operation="change-color"

				local -r selected_color="$OPTARG"
				;;
			d|D)
				[ -z "$operation" ] || _opt_err
				operation="revert-default"
				;;
			l)
				options=("${options[@]}" "list-colors")
				;;
			r|R)
				[ -z "$operation" ] || _opt_err
				operation="restore-color"
				;;
			u)
				options=("${options[@]}" "update-icon-caches")
				;;
			V)
				printf "%s %s\n" "$PROGNAME" "$VERSION"
				exit 0
				;;
			h)
				usage 0
				;;
			v)
				declare -ri VERBOSE=1
				;;
			\?)
				usage 1
				;;
		esac
	done

	shift $((OPTIND-1))

	# Return an error if any positional parameters are found
	[ -z "$1" ] || _fail "illegal parameter -- '$1'"

	case "$operation" in
		change-color)
			_is_valid_color "$selected_color" \
				|| _fail "'$selected_color' is not a valid color"

			verify_privileges

			change_color "$selected_color" || _fatal
			config --new --set "color=$selected_color" || _fatal
			update_icon_caches || _fatal
			;;
		revert-default)
			verify_privileges

			change_color "$DEFAULT_COLOR" || _fatal
			config --new --set "color=$DEFAULT_COLOR" || _fatal
			update_icon_caches || _fatal

			_verbose "Reverted back to the default color of folders."
			;;
		restore-color)
			saved_color="$(config --get color)"

			[ -n "$saved_color" ] \
				|| _exit "cannot get color from a config file."

			_is_valid_color "$saved_color" \
				|| _exit "cannot restore '$saved_color' color of folders."

			verify_privileges

			change_color "$saved_color" || _fatal
			_msg "'$saved_color' color of the folders has been restored."
			;;
	esac

	for option in "${options[@]}"; do
		case "$option" in
			list-colors)
				cat <<- EOF
				List of available colors:

				$(
					eval "$(get_colors)"
					eval "$(get_current_color)"

					declare color prefix

					for color in "${colors[@]}"; do
						if [ "$current_color" = "$color" ]; then
							prefix=">"
						else
							prefix=""
						fi

						printf '%2s %s\n' "$prefix" "$color"
					done
				)

				EOF
				;;
			update-icon-caches)
				verify_privileges

				update_icon_caches || _fatal
				;;
		esac
	done

	_verbose "Done!"
	exit 0
}

main() {
	local icons_dir
	local -a icons_dirs=(
		"/usr/local/share/icons/$THEME_NAME"
		"/usr/share/icons/$THEME_NAME"
		"$HOME/.local/share/icons/$THEME_NAME"
		"$HOME/.icons/$THEME_NAME"
	)

	for icons_dir in "${icons_dirs[@]}"; do
		[ -f "$icons_dir/index.theme" ] || continue
		readonly THEME_DIR="$icons_dir"
		break
	done

	[ -e "$THEME_DIR" ] || _fail "cannot find $THEME_NAME icon theme."

	cmdline "${ARGS[@]}"
}

main
